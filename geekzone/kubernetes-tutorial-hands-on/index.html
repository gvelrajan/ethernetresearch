<!doctype html><html lang=en><head><title>Kubernetes Tutorial - Hands On For Beginners - Ethernet Research</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Ethernet Research: Actionable information about cloud technologies at your fingertips"><meta name=author content="Ganesh Velrajan"><meta property="og:title" content="Kubernetes Tutorial - Hands On For Beginners"><meta property="og:description" content="In the previous two Kubernetes tutorials, we saw how to install and setup a Kubernetes cluster and we discussed the fundamental building blocks of Kubernetes.
In this tutorial, we&rsquo;ll do a hands-on session on how to run a web application as a docker container in the Kubernetes Cluster we created previously."><meta property="og:type" content="article"><meta property="og:url" content="http://www.ethernetresearch.com/geekzone/kubernetes-tutorial-hands-on/"><meta property="og:image" content="http://www.ethernetresearch.com/images/kubernetes/kubernetes.jpg"><meta property="article:published_time" content="2018-08-11T00:00:00+00:00"><meta property="article:modified_time" content="2018-08-11T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://www.ethernetresearch.com/images/kubernetes/kubernetes.jpg"><meta name=twitter:title content="Kubernetes Tutorial - Hands On For Beginners"><meta name=twitter:description content="In the previous two Kubernetes tutorials, we saw how to install and setup a Kubernetes cluster and we discussed the fundamental building blocks of Kubernetes.
In this tutorial, we&rsquo;ll do a hands-on session on how to run a web application as a docker container in the Kubernetes Cluster we created previously."><meta name=generator content="Hugo 0.79.1"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin=anonymous><link rel=stylesheet href=http://www.ethernetresearch.com/fontawesome/css/all.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"><link rel=stylesheet type=text/css href=http://www.ethernetresearch.com/css/styles.css></head><body><div id=container><header><h1><a href=http://www.ethernetresearch.com/>Ethernet Research</a></h1><ul id=social-media><li><a href=https://linkedin.com/in/username title=LinkedIn><i class="fab fa-linkedin fa-lg"></i></a></li><li><a href=https://www.youtube.com/channel/UCnmHCstjZcevizOQ0qmANlw title=Youtube><i class="fab fa-youtube fa-lg"></i></a></li></ul><p><em>Actionable information about cloud technologies</em></p></header><nav><ul><li><a href=http://www.ethernetresearch.com/geekzone/><i class="fa-li fa fa-lg"></i><span>GeekZone</span></a></li><li><a href=http://www.ethernetresearch.com/articles/><i class="fa-li fa fa-lg"></i><span>Articles</span></a></li><li><a href=http://www.ethernetresearch.com/about/><i class="fa-li fa fa-lg"></i><span>About Us</span></a></li><li><a href=http://www.ethernetresearch.com/online-courses-training/><i class="fa-li fa fa-lg"></i><span>Online Courses</span></a></li><li><a href=http://www.ethernetresearch.com/contact/><i class="fa-li fa fa-lg"></i><span>Contact</span></a></li></ul></nav><main><article><h1>Kubernetes Tutorial - Hands On For Beginners</h1><aside><ul><li><time class=post-date datetime=2018-08-11T00:00:00Z>Aug 11, 2018</time></li><li>Categories:
<em><a href=http://www.ethernetresearch.com/categories/geekzone>GeekZone</a>
,
<a href=http://www.ethernetresearch.com/categories/kubernetes>Kubernetes</a></em></li><li><em><a href=http://www.ethernetresearch.com/tags/container>#Container</a>
,
<a href=http://www.ethernetresearch.com/tags/docker>#Docker</a>
,
<a href=http://www.ethernetresearch.com/tags/kubernetes>#Kubernetes</a></em></li><li>8 minute read</li></ul></aside><div class=featured_image><a href=http://www.ethernetresearch.com/geekzone/kubernetes-tutorial-hands-on/ title="Kubernetes Tutorial - Hands On For Beginners"><img src=http://www.ethernetresearch.com/images/kubernetes/kubernetes.jpg></a></div><p>In the previous two Kubernetes tutorials, we saw how to install and setup a Kubernetes cluster and we discussed the fundamental building blocks of Kubernetes.</p><p>In this tutorial, we&rsquo;ll do a hands-on session on how to run a web application as a docker container in the  <a href=http://35.238.255.76/geekzone/kubernetes-tutorial-how-to-install-kubernetes-on-ubuntu/>Kubernetes Cluster we created</a> previously.</p><h2 id=sample-web-application>Sample Web Application</h2><p>Here is the sample  &ldquo;Hello, World&rdquo; Node.js web application that we&rsquo;ll use for this exercise.</p><pre><code>$ cat myapp.js
var http = require('http');
var rand = Math.floor(Math.random() * 100);
//create a server object:
http.createServer(function (req, res) {
res.writeHead(200, {'Content-Type': 'text/html'});
res.write('Hello World!'); //write a response to the client
res.write('My number is: ' + rand); //write a response to the client
res.end(); //end the response
}).listen(80); //the server object listens on port 80
</code></pre><p>Here is the Dockerfile we&rsquo;ll use to package this JavaScript application into a docker container image.</p><pre><code>$ cat Dockerfile
FROM alpine:latest
RUN apk update &amp;&amp; apk add nodejs
RUN mkdir -p /usr/src/app
COPY ./myapp.js /usr/src/app
WORKDIR /usr/src/app
EXPOSE 80 
CMD [&quot;node&quot;,&quot;myapp.js&quot;]
</code></pre><p>Refer to the Docker Tutorial on <a href=http://35.238.255.76/geekzone/docker-container-tutorial-creating-docker-container-images/>How to build a Docker Image</a>, that we covered earlier.</p><h2 id=build-docker-image>Build Docker Image</h2><p>Build the docker image using the below command.  Replace the registry name &ldquo;gvelrajan&rdquo; with your own registry in DockerHub.</p><pre><code>$ docker image build -t gvelrajan/hello-world:v1.0 .
</code></pre><p>Once the image is built, push the image to the DockerHub, so that you can access it from anywhere.</p><pre><code>$ docker push gvelrajan/hello-world:v1.0
</code></pre><h2 id=run-the-docker-image-in-kubernetes-cluster>Run the Docker Image in Kubernetes Cluster</h2><p>Kubernetes is so popular because it makes the job of managing containers very easy.  All you need to do is describe your intent on &ldquo;How to launch your web application&rdquo; in a YAML file and Kubernetes will manifest that intent for you.  Kubernetes hides all the implementation details from the user.</p><p>For example, to run our &ldquo;Hello, World&rdquo; docker image we just built, we need to create a Kubernetes Pod YAML file and provide it as an input to Kubernetes.</p><p>Kubernetes will take care of scheduling the pod in one of the available nodes in the cluster.</p><h2 id=create-a-pod>Create a Pod</h2><p>Here is our Pod YAML file for our &ldquo;Hello, World&rdquo; webapp.</p><pre><code>$ cat pod.yaml
apiVersion: v1
kind: Pod                                            # 1
metadata:
  name: helloworld                                   # 2
  labels:                                            
    app: helloworld
spec:                                                # 3
  containers:
    - image: gvelrajan/hello-world:v1.0              # 4
      imagePullPolicy: Always
      name: helloworld                               # 5
      ports:
        - containerPort: 80                          # 6
</code></pre><p><strong>Description of various fields in the YAML file:</strong></p><p>#1 kind:</p><p>#2 name & labels</p><p>#3 spec</p><p>#4 image</p><p>#5 name</p><p>#6 containerPort</p><p>Request the Kubernetes master node to create a Kubernetes Pod by executing  the following command in the master node.</p><pre><code>master$ kubectl create -f pod.yaml
pod/helloworld created
</code></pre><p>Check if the pod has been created.</p><pre><code>master$ kubectl get pod
NAME                          READY     STATUS    RESTARTS   AGE
helloworld                    1/1       Running   0          10s
</code></pre><p>To know more about the pod, use the &ldquo;Kubectl describe pod&rdquo; command as shown below.</p><pre><code>master$ kubectl describe pod helloworld
Name:         helloworld
Namespace:    default
Node:         instance-2/10.160.0.3
Start Time:   Sat, 11 Aug 2018 05:14:09 +0000
Labels:       app=helloworld
Annotations:  
Status:       Running
IP:           192.168.56.18
Containers:
  helloworld:
    Container ID:   docker://91458eb52daaff0eec5df25fd9da004e721e9c56e3b06f1715b31821178ed155
    Image:          gvelrajan/hello-world:v2.0
    Image ID:       docker-pullable://gvelrajan/hello-world@sha256:6d15f54fce820eb2628a943734a60cbc042eda1e696d97b6
3f159f88b0269f91
    Port:           80/TCP
    Host Port:      0/TCP
    State:          Running
      Started:      Sat, 11 Aug 2018 05:14:14 +0000
    Ready:          True
    Restart Count:  0
    Environment:    
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-n8l4x (ro)
Conditions:
  Type              Status
  Initialized       True 
  Ready             True 
  ContainersReady   True 
  PodScheduled      True 
Volumes:
  default-token-n8l4x:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-n8l4x
    Optional:    false
QoS Class:       BestEffort
Node-Selectors:  
Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s
                 node.kubernetes.io/unreachable:NoExecute for 300s
Events:
  Type    Reason     Age   From                 Message
  ----    ------     ----  ----                 -------
  Normal  Scheduled  24s   default-scheduler    Successfully assigned default/helloworld to instance-2
  Normal  Pulling    23s   kubelet, instance-2  pulling image &quot;gvelrajan/hello-world:v2.0&quot;
  Normal  Pulled     19s   kubelet, instance-2  Successfully pulled image &quot;gvelrajan/hello-world:v2.0&quot;
  Normal  Created    19s   kubelet, instance-2  Created container
  Normal  Started    19s   kubelet, instance-2  Started container
master$
</code></pre><p>Each pod gets its own local IP address in Kubernetes.  The pod above has been assigned an IP address of 192.168.56.18.</p><p>What if we need to scale up the webapp we created ?  Do we execute the above pod creation command again to create one more instance of the same pod?</p><pre><code>master$ kubectl create -f pod.yaml
Error from server (AlreadyExists): error when creating &quot;pod.yaml&quot;: pods &quot;helloworld&quot; already exists
</code></pre><p>This is not the right way to scale up pod or containers in Kubernetes.</p><p>This will serve as a nice segway to our next concept, which is Deployment.</p><h2 id=create-a-deployment>Create a Deployment</h2><p>Kubernetes uses a Deployment YAML file to specify how many replicas of a pod we need and it will take care of spawning that many number of pods across different nodes in the cluster.</p><p>We don&rsquo;t have to worry about how and where the pods needs to be instantiated.  Kubernetes will take care of it on our behalf.</p><p>Kubernetes will even spawn a new pod if an existing pod dies.</p><p>Here is our Kubernetes Deployment file to spawn two pods for our webapp.</p><pre><code>master$ cat deployment.yaml 
apiVersion: extensions/v1beta1
kind: Deployment                                          # 1
metadata:
  name: helloworld
spec:
  replicas: 2                                             # 2
  minReadySeconds: 15
  strategy:
    type: RollingUpdate                                   # 3
    rollingUpdate: 
      maxUnavailable: 1                                   # 4
      maxSurge: 1                                         # 5
  template:                                               # 6
    metadata:
      labels:
        app: helloworld                                   # 7
    spec:
      containers:
        - image: gvelrajan/hello-world:v2.0 
          imagePullPolicy: Always                         # 8
          name: helloworld 
          ports:
            - containerPort: 80
</code></pre><p>Request Kubernetes Master to deploy our application.</p><pre><code>master$ kubectl create -f deployment.yaml 
deployment.extensions/helloworld created
</code></pre><p>check the status of the deployment.</p><pre><code>master$ kubectl get deployment
NAME         DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
helloworld   2         2         2            1           24s
</code></pre><p>To know more about the Deployment, execute the &ldquo;kubectl describe deployment&rdquo; command.</p><pre><code>master$ kubectl get pods
NAME                          READY     STATUS    RESTARTS   AGE
helloworld                    1/1       Running   0          3h
helloworld-59d46f94c5-ddmvr   1/1       Running   0          2h
helloworld-59d46f94c5-w8gcx   1/1       Running   0          2h
</code></pre><p>We have 3 pods of the &ldquo;Hello world&rdquo; application running now, including the one we created manually in the previous section.</p><p>Let&rsquo;s delete that pod now.</p><pre><code>master$ kubectl delete pod helloworld
pod &quot;helloworld&quot; deleted

master$ kubectl get pods
NAME                          READY     STATUS    RESTARTS   AGE
helloworld-59d46f94c5-ddmvr   1/1       Running   0          2h
helloworld-59d46f94c5-w8gcx   1/1       Running   0          2h
</code></pre><p>Get detailed info on these pods.</p><pre><code>master$ kubectl describe pods
Name:           helloworld-59d46f94c5-ddmvr
Namespace:      default
Node:           instance-2/10.160.0.3
Start Time:     Sat, 11 Aug 2018 05:50:01 +0000
Labels:         app=helloworld
                pod-template-hash=1580295071
Annotations:    
Status:         Running
IP:             192.168.56.23
Controlled By:  ReplicaSet/helloworld-59d46f94c5
Containers:
  helloworld:
    Container ID:   docker://7068f2006645d21824a29fc25122195f96f8b926fb6c251c3ec9b0454f1c835b
    Image:          gvelrajan/hello-world:v4.0
    Image ID:       docker-pullable://gvelrajan/hello-world@sha256:a499383b22475f7b2ac805003a1c432f6d4a4ca7196e66a4dabb94f10dd061c2
    Port:           80/TCP
    Host Port:      0/TCP
    State:          Running
      Started:      Sat, 11 Aug 2018 05:50:11 +0000
    Ready:          True
    Restart Count:  0
    Environment:    
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-n8l4x (ro)
Conditions:
  Type              Status
  Initialized       True 
  Ready             True 
  ContainersReady   True 
  PodScheduled      True 
Volumes:
  default-token-n8l4x:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-n8l4x
    Optional:    false
QoS Class:       BestEffort
Node-Selectors:  
Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s
                 node.kubernetes.io/unreachable:NoExecute for 300s
Events:          


Name:           helloworld-59d46f94c5-w8gcx
Namespace:      default
Node:           instance-2/10.160.0.3
Start Time:     Sat, 11 Aug 2018 05:50:01 +0000
Labels:         app=helloworld
                pod-template-hash=1580295071
Annotations:    
Status:         Running
IP:             192.168.56.24
Controlled By:  ReplicaSet/helloworld-59d46f94c5
Containers:
  helloworld:
    Container ID:   docker://a21882e7dd55d831fe965dfe7dfeb325165bcc13326b4c31e9c1b11dabbbd75e
    Image:          gvelrajan/hello-world:v4.0
    Image ID:       docker-pullable://gvelrajan/hello-world@sha256:a499383b22475f7b2ac805003a1c432f6d4a4ca7196e66a4
dabb94f10dd061c2
    Port:           80/TCP
    Host Port:      0/TCP
    State:          Running
      Started:      Sat, 11 Aug 2018 05:50:08 +0000
    Ready:          True
    Restart Count:  0
    Environment:    
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-n8l4x (ro)
Conditions:
  Type              Status
  Initialized       True 
  Ready             True 
  ContainersReady   True 
  PodScheduled      True 
Volumes:
  default-token-n8l4x:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-n8l4x
    Optional:    false
QoS Class:       BestEffort
Node-Selectors:  
Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s
                 node.kubernetes.io/unreachable:NoExecute for 300s
Events:
</code></pre><p>Kubernetes assigns each pod its own unique local IP address.</p><p>Should the client remember the IP address of each of these pods to communicate with them?  Moreover the IP address is a local IP address and not a public IP address.</p><p>So how do we make clients talk to each of these pods?</p><p>That&rsquo;s where the Kubernetes Service comes in handy.</p><p>A Kubernetes Services creates an abstraction on top of all the pods that provides the same functionality, so that the clients are not aware of the multiple instances of the pod.  Kubernetes Service exposes  a single interface for clients to communicate with the pods.</p><p>Kubernetes Service provides a load-balancers as well as a NAT service.  The load-balancer helps in load-balancing the traffic equally between the pods.  The NAT service provides translation between the public IP and Port and cluster local IP and port.</p><h2 id=create-a-service>Create a Service</h2><p>Next create a load-balancer and NAT service.</p><pre><code>master$ cat service.yaml 
apiVersion: v1
kind: Service              # 1
metadata:
  name: helloworld-lb
spec:
  externalIPs:
  - 10.160.0.3
  type: LoadBalancer       # 2
  ports:
  - port: 80               # 3
    protocol: TCP          # 4
    targetPort: 80         # 5
  selector:                # 6
    app: helloworld        # 7
</code></pre><p>Request Kubernetes to create the service.</p><pre><code>master$ kubectl create -f service.yaml 
service/helloworld-lb created
</code></pre><p>Check the status of the service.</p><pre><code>master$ kubectl get service
NAME            TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE
helloworld-lb   LoadBalancer   10.98.193.112   10.160.0.3    80:31870/TCP   9s
kubernetes      ClusterIP      10.96.0.1               443/TCP        34d
</code></pre><p>To know the details use the describe command.</p><pre><code>master$ kubectl describe service helloworld-lb
Name:                     helloworld-lb
Namespace:                default
Labels:                   
Annotations:              
Selector:                 app=helloworld
Type:                     LoadBalancer
IP:                       10.98.193.112
External IPs:             10.160.0.3
Port:                       80/TCP
TargetPort:               80/TCP
NodePort:                   31870/TCP
Endpoints:                192.168.56.23:80,192.168.56.24:80
Session Affinity:         None
External Traffic Policy:  Cluster
Events:
</code></pre><h2 id=wrap-it-up>Wrap it up</h2><p>Check the browser:</p><pre><code>$ cat test.sh

for var in {1..100} 
do 
    curl http://10.160.0.3
    echo &quot;\n&quot;
done

$ sh test.sh 
\Hello World!My number is:    23

Hello World!My number is:    26

Hello World!My number is:    26

Hello World!My number is:    23

Hello World!My number is:    23

Hello World!My number is:    26

Hello World!My number is:    26

Hello World!My number is:    23

Hello World!My number is:    23

Hello World!My number is:    23

Hello World!My number is:    23

Hello World!My number is:    23

Hello World!My number is:    26

Hello World!My number is:    26

Hello World!My number is:    26

...
...
</code></pre><p>In the above output, we see that the &ldquo;Curl&rdquo; output alternates between two different random numbers - each representing a pod in the cluster.</p><p>This proves that the Kubernetes Service is load-balancing our requests to the 2 different Pods running in the cluster.</p></article><section class=post-nav><ul><li><a href=http://www.ethernetresearch.com/geekzone/kubernetes-tutorial-getting-started-on-the-basics/><i class="fa fa-chevron-circle-left"></i>Kubernetes Tutorial - Getting Started on the Basics</a></li><li><a href=http://www.ethernetresearch.com/geekzone/docker-tutorial-persistent-storage-volumes-and-stateful-containers/>Docker Containers Tutorial - Persistent Storage Volumes and Stateful Containers <i class="fa fa-chevron-circle-right"></i></a></li></ul></section></main><footer><h6>Copyright © 2021 - Ethernet Research | All Rights Reserved.</h6></footer></div><script src=http://www.ethernetresearch.com/js/scripts.js></script></body></html>